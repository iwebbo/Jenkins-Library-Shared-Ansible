#!/usr/bin/env groovy

/**
 * Fonction principale de d√©ploiement Ansible simplifi√©e
 * Usage: ansibleDeploy([
 *   playbook: 'site.yml', 
 *   targetServers: 'web01,web02',
 *   ansibleVars: [app_version: '1.2.3', debug_mode: 'true']
 * ])
 */
def call(Map config = [:]) {
    // Validation des param√®tres obligatoires
    if (!config.playbook) {
        error("Le param√®tre 'playbook' est obligatoire")
    }
    if (!config.targetServers) {
        error("Le param√®tre 'targetServers' est obligatoire")
    }
    
    // Configuration par d√©faut
    def defaultConfig = readAnsibleConfig(config.config_path ?: '.')

    // Ajout des valeurs qui ne sont pas dans ansible.cfg
    defaultConfig.ansible_path = ''
    defaultConfig.config_path = '.'
    defaultConfig.targetServers = ''
    defaultConfig.playbook = ''
    defaultConfig.ansibleVars = [:]
    defaultConfig.tags = ''
    defaultConfig.checkMode = false
    defaultConfig.verbose = false
    defaultConfig.timeout = 3600
    defaultConfig.notification = true
    defaultConfig.forks = 10
    defaultConfig.become = true
    defaultConfig.becomeUser = 'root'

    config = defaultConfig + config

    echo "üöÄ D√©but du d√©ploiement Ansible"
    echo "Playbook: ${config.playbook}"
    echo "Target Servers: ${config.targetServers}"
    if (config.ansibleVars) {
        echo "üîß Variables Ansible: ${config.ansibleVars}"
    }
    
    try {
        // √âtape 1: D√©tection du type de serveurs et credentials
        stage('D√©tection Credentials') {
            config.credentialInfo = detectServerCredentials(config.targetServers, config.inventory)
            echo "üîë Credentials d√©tect√©s: ${config.credentialInfo}"
        }
        
        // √âtape 2: Validation
        stage('Validation Ansible') {
            ansibleValidate(config)
        }
        
        // √âtape 3: Pr√©paration des variables
        stage('Pr√©paration Variables') {
            prepareAnsibleVars(config)
        }
        
        // √âtape 4: Ex√©cution du playbook avec credentials
        stage('Ex√©cution Playbook') {
            executeAnsiblePlaybookWithCredentials(config)
        }
        
        // √âtape 5: Notification de succ√®s
        if (config.notification) {
            stage('Notification') {
                ansibleNotify([
                    status: 'success',
                    playbook: config.playbook,
                    targetServers: config.targetServers,
                    ansibleVars: config.ansibleVars,
                    duration: currentBuild.durationString
                ])
            }
        }
        
    } catch (Exception e) {
        // Notification d'√©chec
        if (config.notification) {
            ansibleNotify([
                status: 'failure',
                playbook: config.playbook,
                targetServers: config.targetServers,
                error: e.message,
                duration: currentBuild.durationString
            ])
        }
        throw e
    }
}
/**
 * Lit la configuration depuis ansible.cfg
 */
private def readAnsibleConfig(String configPath) {
    def config = [:]
    
    try {
        def configFile = "${configPath}/ansible.cfg"
        if (fileExists(configFile)) {
            def content = readFile(configFile)
            
            content.split('\n').each { line ->
                line = line.trim()
                if (line.contains('inventory =')) {
                    config.inventory = line.split('=')[1].trim()
                    echo "Load configuration from ansible.cfg: ${config.inventory}"
                }
                if (line.contains('playbook_dir =')) {
                    config.playbook_dir = line.split('=')[1].trim()
                    echo "Playbook directory: ${config.playbook_dir}"
                }
            }
        }
    } catch (Exception e) {
        echo "‚ö†Ô∏è Error load from ansible.cfg: ${e.message}"
    }
    
    return config
}

/**
 * D√©tecte le type de serveurs et retourne les credentials appropri√©s
 */
private def detectServerCredentials(String targetServers, String inventory) {
    def credentialInfo = [
        hasWindows: false,
        hasLinux: false,
        windowsCredentialId: 'credentials-id-windows-user-password',
        linuxCredentialId: 'ssh-key-ansible-user-secret-file',
        mixedEnvironment: false
    ]
    
    script {
        try {
            // R√©cup√©ration des informations sur les serveurs cibles
            def serverInfo = sh(
                script: """
                    ansible ${targetServers} -i ${inventory} -m setup -a "filter=ansible_os_family" --one-line 2>/dev/null || \
                    ansible ${targetServers} -i ${inventory} --list-hosts 2>/dev/null
                """,
                returnStdout: true
            ).trim()
            
            echo "‚ÑπÔ∏è  Informations serveurs: ${serverInfo}"
            
            // D√©tection Windows (recherche de patterns Windows)
            if (serverInfo.toLowerCase().contains('windows') || 
                serverInfo.toLowerCase().contains('win') ||
                targetServers.toLowerCase().contains('win') ||
                targetServers.toLowerCase().contains('windows')) {
                credentialInfo.hasWindows = true
                echo "ü™ü Serveurs Windows d√©tect√©s"
            }
            
            // D√©tection Linux (par d√©faut ou patterns Linux)
            if (serverInfo.toLowerCase().contains('redhat') || 
                serverInfo.toLowerCase().contains('ubuntu') ||
                serverInfo.toLowerCase().contains('debian') ||
                serverInfo.toLowerCase().contains('centos') ||
                targetServers.toLowerCase().contains('linux') ||
                targetServers.toLowerCase().contains('web') ||
                targetServers.toLowerCase().contains('db') ||
                !credentialInfo.hasWindows) {  // Par d√©faut = Linux
                credentialInfo.hasLinux = true
                echo "üêß Serveurs Linux d√©tect√©s"
            }
            
            // Environnement mixte
            if (credentialInfo.hasWindows && credentialInfo.hasLinux) {
                credentialInfo.mixedEnvironment = true
                echo "üîÑ Environnement mixte d√©tect√© (Windows + Linux)"
            }
            
        } catch (Exception e) {
            echo "‚ö†Ô∏è  Impossible de d√©tecter le type de serveurs, utilisation Linux par d√©faut: ${e.message}"
            credentialInfo.hasLinux = true
        }
    }
    
    return credentialInfo
}

/**
 * Pr√©pare les variables Ansible pour l'ex√©cution
 */
private def prepareAnsibleVars(Map config) {
    // Variables syst√®me automatiques
    def systemVars = [
        'jenkins_build_number': env.BUILD_NUMBER,
        'jenkins_build_url': env.BUILD_URL,
        'jenkins_job_name': env.JOB_NAME,
        'deployment_timestamp': new Date().format('yyyy-MM-dd_HH-mm-ss'),
        'deployed_by': env.BUILD_USER ?: 'jenkins'
    ]
    
    // Conversion String vers Map si n√©cessaire
    if (config.ansibleVars instanceof String) {
        echo "üîÑ Conversion des variables String vers Map"
        def userVars = [:]
        
        config.ansibleVars.split('\n').each { line ->
            line = line.trim()
            if (line && line.contains('=')) {
                def parts = line.split('=', 2)
                if (parts.length == 2) {
                    userVars[parts[0].trim()] = parts[1].trim()
                }
            }
        }
        config.ansibleVars = systemVars + userVars  // ‚Üê Fusion des deux Maps
    } else {
        config.ansibleVars = systemVars + config.ansibleVars
    }
}

/**
 * Ex√©cute le playbook Ansible avec les bons credentials
 */
private def executeAnsiblePlaybookWithCredentials(Map config) {
    def credInfo = config.credentialInfo
    
    if (credInfo.mixedEnvironment) {
        echo "üîÑ Ex√©cution en environnement mixte"
        executePlaybookMixedEnvironment(config)
    } else if (credInfo.hasWindows) {
        echo "ü™ü Ex√©cution pour serveurs Windows"
        executePlaybookWindows(config)
    } else {
        echo "üêß Ex√©cution pour serveurs Linux"
        executePlaybookLinux(config)
    }
}

/**
 * Ex√©cution pour serveurs Linux
 */
private def executePlaybookLinux(Map config) {
    withCredentials([
        sshUserPrivateKey(
            credentialsId: config.credentialInfo.linuxCredentialId,
            keyFileVariable: 'SSH_KEY_FILE',
            usernameVariable: 'SSH_USER'
        )
    ]) {
        executePlaybook(config, 'linux')
    }
}

/**
 * Ex√©cution pour serveurs Windows
 */
private def executePlaybookWindows(Map config) {
    withCredentials([
        usernamePassword(
            credentialsId: config.credentialInfo.windowsCredentialId,
            usernameVariable: 'WIN_USER',
            passwordVariable: 'WIN_PASSWORD'
        )
    ]) {
        // Configuration des variables d'environnement pour Windows
        env.ANSIBLE_CONNECTION = 'winrm'
        env.ANSIBLE_WINRM_TRANSPORT = 'ntlm'
        env.ANSIBLE_WINRM_SERVER_CERT_VALIDATION = 'ignore'
        
        executePlaybook(config, 'windows')
    }
}

/**
 * Ex√©cution en environnement mixte (Linux + Windows)
 */
private def executePlaybookMixedEnvironment(Map config) {
    withCredentials([
        sshUserPrivateKey(
            credentialsId: config.credentialInfo.linuxCredentialId,
            keyFileVariable: 'SSH_KEY_FILE',
            usernameVariable: 'SSH_USER'
        ),
        usernamePassword(
            credentialsId: config.credentialInfo.windowsCredentialId,
            usernameVariable: 'WIN_USER',
            passwordVariable: 'WIN_PASSWORD'
        )
    ]) {
        echo "üîÑ Configuration pour environnement mixte"
        executePlaybook(config, 'mixed')
    }
}

/**
 * Ex√©cute le playbook Ansible avec les param√®tres appropri√©s
 */
private def executePlaybook(Map config, String serverType) {
    // Construction des param√®tres de base
    def playbookParams = [
        playbook: config.playbook,
        inventory: config.inventory,
        limit: config.targetServers,
        disableHostKeyChecking: true,
        colorized: true,
        become: config.become,
        becomeUser: config.becomeUser,
        forks: config.forks
    ]
    
    // Configuration sp√©cifique selon le type de serveur
    switch(serverType) {
        case 'linux':
            playbookParams.credentialsId = config.credentialInfo.linuxCredentialId
            break
        case 'windows':
            // Pour Windows, utilisation des variables d'environnement
            playbookParams.become = false  // Pas de sudo sur Windows
            break
        case 'mixed':
            // En environnement mixte, utiliser le credential Linux par d√©faut
            // Les credentials Windows sont g√©r√©s via les variables d'environnement
            playbookParams.credentialsId = config.credentialInfo.linuxCredentialId
            break
    }
    
    // Ajout des tags si sp√©cifi√©s
    if (config.tags) {
        playbookParams.tags = config.tags
        echo "üè∑Ô∏è  Tags appliqu√©s: ${config.tags}"
    }
    
    // Construction des variables extra avec HOST automatique
    def allVars = config.ansibleVars ?: [:]
    
    // Ajout automatique de la variable HOST depuis TARGET_SERVERS
    allVars['HOST'] = config.targetServers
    echo "üéØ Variable HOST ajout√©e: ${config.targetServers}"
    
    if (allVars) {
        def extraVarsString = allVars.collect { k, v -> "${k}=${v}" }.join(' ')
        playbookParams.extraVars = [
            extraVars: extraVarsString
        ]
        echo "üîß Variables extra: ${extraVarsString}"
    }
    
    // Mode check si demand√©
    if (config.checkMode) {
        playbookParams.check = true
        echo "üîç Mode check activ√© - Aucune modification ne sera appliqu√©e"
    }
    
    // Verbosit√©
    if (config.verbose) {
        playbookParams.verbose = true
        echo "üì¢ Mode verbose activ√©"
    }
    
    echo "üéØ Ex√©cution sur les serveurs: ${config.targetServers}"
    echo "üìã Playbook: ${config.playbook}"
    echo "üñ•Ô∏è  Type de serveurs: ${serverType}"
    
    // Timeout avec gestion d'erreur
    timeout(time: config.timeout, unit: 'SECONDS') {
        try {
            // Utilisation du plugin Ansible Jenkins
            ansiblePlaybook(playbookParams)
            echo "‚úÖ Playbook ex√©cut√© avec succ√®s"
        } catch (Exception e) {
            error("‚ùå √âchec de l'ex√©cution du playbook: ${e.message}")
        }
    }
}